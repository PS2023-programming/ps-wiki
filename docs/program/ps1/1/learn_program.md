# 框架代码导读

!!! Warning "难度警示"

    我们在上手任何任务时都存在一个学习曲线。在项目任务中，尤其是对于零基础的同学，这将会是学习曲线最为陡峭之处。*请充分重视第一阶段，否则你很有可能无法完成后续所有阶段。*

    这一部分要求完成的任务很少，而我们仍为它[安排了一周的时间](../../../../schedule/ps1/#_5)，**但这不是中间休息时间**。我们希望你能用一周的时间[认真阅读讲义](../../../#_3)，并确保理解了框架的代码。

!!! info "关于 GPT 的使用"

    请尽量不要让 GPT 等大语言模型直接帮你生成作业代码。你可以让它为你解释讲义中你看不懂的技术细节，也可以让它为你提供某样技术细节的实现乃至示例代码。

    但如果你直接让 GPT 生成项目需要添加的代码，可能会有如下几点后果：

    + 你可能并不懂 GPT 的代码为何能够工作，这可能令你在后续需要修改该代码时遇到困难。
    + GPT 的代码可能是错误的，而你没有进行足够的阅读或理解工作，导致你无法进行项目。

RTFSC 是 Reading The Fucking Source Code 的缩写，来自于 [Linus](https://zh.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9) 在邮件中的「友善」嘴臭。

虽然骂人不好，但这话更像自言自语，有如「It's time to read the fucking source code」。它提醒我们：无论是在初步接手一个项目，抑或是遇到了一些疑难杂症时，沉下心来读一读源代码都很可能对我们大有裨益。

但不少同学作为初学者，哪怕对于小型项目的结构和代码都感到一头雾水：为什么有这么多源文件？各种代码文件之间有什么关系？代码里怎么到处都是我没见过的 token 和语法？该怎么编译整个项目？要知道这些问题的答案，必须对一些 C/C++ 的高级语法，以及 C/C++ 项目的构建具有基本的知识。

由此，作为第一阶段的开端，在本部分中我们为大家介绍阅读框架代码所必须的前置知识，并通过阅读代码了解框架代码的大略架构。

## 代码组织与构建

在第零阶段我们说过，项目中共有两个可执行文件：游戏和启动器。

启动器是一个单源文件程序，而游戏对应着多份源代码。在 OJ 中，大家也许习惯于编写一个源文件而得到对应的程序，但是对于复杂的项目，只使用一个源文件构建得到一个程序是不现实的。试想如果一个源文件中有着数万乃至数十万行代码，会使得阅读和维护代码变得多么麻烦？

因此，我们需要将代码按照模块分成多个文件。你可以在如下目录下找到游戏的源代码：`test/phase1` 和 `minitui`。你还会注意到代码文件分为两类：

+ `.h` 结尾的**头文件**（Header File），一般存放在 `include` 目录下。
+ `.cpp` 结尾的**源文件**（Source File），一般存放在 `source` 目录下。

下面我们来细讲一下这两类文件的区别和作用，并介绍一下预编译命令以及代码的构建流程。

### 头文件和 `#include`

你每次编写的代码的第一行都有可能是 `#include <cstdio>` 或 `#include <iostream>` 乃至 `#include <bits/stdc++.h>`。这些尖括号内的文件就是标准库为我们提供的头文件。

头文件的作用是提供变量的 `extern` 声明和[函数声明](../../../../lang/func/)（这些声明的具体作用我们后面讨论），它一般通过 `#include` 命令而被引入到程序中（这种引入就是文本替换，并可以递归）。

`#include` 这种以 `#` 起始的命令叫做**预编译命令**。处理预编译命令是 C/C++ 源文件编译流程的第一步，我们在此后还会遇见其它的预编译命令，它们同样具有重要作用。

???+ example "观察 `#include` 命令的作用和预编译过程"
    你可以写一个简单的 Hello World 程序（`hello.cpp`），并使用如下命令指示编译器进行预编译：

    ```shell
    g++ -E hello.cpp -o hello_pre.cpp
    ```

    观察 `hello_pre.cpp`，你发现了什么？

#### 头文件的搜索路径

在引用头文件如 `cstdio.h` 时，我们发现头文件既不在代码文件对应的目录下，也不在 `PATH` 环境变量所指定的路径下，GCC 到底是从哪里找到这个文件的呢？

如果你使用带语法提示的编辑器或 IDE，那么在代码文件中你可能发现引用诸如 `ansi.h` 或 `basics.h` 时会被标红线，提示找不到该文件，但编译时却可以通过，这是为什么呢？

这些都和 `#include<$FILE>` 时编译器的搜索路径有关。在这一格式的命令中，编译器会从标准库 `include` 路径下寻找对应的文件，然后从用户指定的 `include` 路径中寻找文件。如果你执行 `echo | gcc -xc++ -E -v -` 命令，你将会看到：

```shell
#include <...> search starts here:
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include/c++
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include/c++/x86_64-pc-msys
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include/c++/backward
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include-fixed
 /usr/include
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/../../../../lib/../include/w32api
```

要想增加 `#include<>` 的搜索路径，可以使用 GCC 提供的 `-I` 选项，试试执行 `echo | gcc -xc++ -E -v -I . -`，输出结果出现了什么不同？

### 多源文件程序的构建

*本部分为了切合大家的学习阶段作了简化。在《计算机系统基础》中大家会学习到更详细的内容。*

#### 构建可执行程序的流程

在[理论课堂](http://cslabcms.nju.edu.cn/problem_solving/images/a/a1/Lecture1-6_2019-11-12_%E5%A6%82%E4%BD%95%E5%B0%86%E7%AE%97%E6%B3%95%E5%91%8A%E8%AF%89%E8%AE%A1%E7%AE%97%E6%9C%BA.pptx)上，我们已经知道了「将程序告诉计算机」的方式——二进制代码。在课堂上，我们还看到了编程语言从机器语言、汇编语言再到高级程序设计语言的演进。

而在可执行程序的构建中，我们则是反其道而行之——从高级程序设计语言的源文件，得到汇编语言文件，再得到二进制代码文件。

但是，对于多源文件的程序，它又是怎么样构建成一个二进制程序的呢？是先合并源代码，再统一翻译，还是在每份源代码翻译之后链接呢？下面我们就来介绍。

多源文件程序的构建流程大体可分为预处理、编译、汇编、链接四个步骤，前三步是每份源代码独立经历的。构建只针对源文件而不直接针对头文件。

+ 预处理 `cpp`：在这一步，源文件所有的 `#` 预编译命令都被展开。头文件在此步被引入。
+ 编译 `ccl`：在这一步，预处理后的源文件被**分别**编译成汇编代码文件。
+ 汇编 `as`：在这一步，汇编代码文件被**分别**编译为可重定位目标文件（`.o` 文件），在 Windows 平台上，它是 [COFF 格式](https://en.wikipedia.org/wiki/COFF0)，在 Linux 平台上，它是 [ELF 格式](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)。
+ 链接 `ld`：在这一步，多个可重定位目标文件被**链接**成一个完整的可执行文件，在 Windows 平台上，它是 [PE 格式](https://en.wikipedia.org/wiki/Portable_Executable)，即常见的 exe 程序，在 Linux 平台上，它仍是 [ELF 格式](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)。

上述流程可以被表示为：

![构建流程](../../../../pics/project-1-1.png)

GCC 提供了细粒度地控制构建流程的选项，展示如下：

```text
-E      Preprocess only; do not compile, assemble or link.
-S      Compile only; do not assemble or link.
-c      Compile and assemble, but do not link.
```

在现阶段，我们不是很关心预处理、编译所得到的中间产物。因此为方便起见，我们把预处理、编译、汇编三步（图上显示的「翻译器」过程）统称为编译，即把一个源代码文件翻译成一个目标文件的过程。

多源文件的编程事实上是一种**模块化编程**。我们把每个源文件对应的部分称为一个**模块**。

#### 符号与目标文件编译

容易推想，在模块化编程中，模块之间不可能是完全相互独立的：一个模块可能需要用到别的模块的**全局变量**或函数，也可能需要提供变量和函数供其他模块使用。

我们把函数和变量统称为**符号**，上面的问题可以被总结为跨模块的**符号引用**。

???+ question "符号引用在做什么？"

    调用函数、使用全局变量本质上都是通过它们的**地址**进行的。引用符号就是在引用符号的**地址**。

但是，编译器在把源代码编译为目标文件之前，并不知道这个目标文件会和哪些模块链接，更不知道那些模块会有哪些符号，在编译器看来，只有在文件中**声明了**的符号才能被使用。

声明的作用是**告诉编译器一个符号的引用方法**。你得告诉编译器，这个符号是函数还是变量，是什么类型，有哪些参数？否则编译器无从使用它。

声明包括名称（也就是函数或变量名），类型（变量类型或函数原型），性质（静态/全局）。声明的实现（即**定义**，函数定义或全局变量的初始化）可以位于本模块中（**强符号**），也可以不位于本模块中（**弱符号**）。

???+ info "外部变量的声明"

    未赋初始值的变量默认视为一个弱符号。如果想显式表明一个变量是一个弱符号，使用 `extern` 关键字。

对于那些在本模块中无法确定其绝对地址或者相对地址的符号，编译器会留下重定位信息（即 `.rel.text` 和 `.rel.data` 节），要求链接器在链接时为自己替换模块中的符号引用地址（即**重定位**）。另外，对于声明过的所有强符号或弱符号，编译器都会将它们的信息写入目标文件，以供链接器使用。这样生成的文件就是**可重定位目标文件**。

#### 头文件：接口声明的集合

一个模块可能实现了若干它希望被其他模块使用的函数和变量，我们把它们称作**接口**。当其他模块需要使用接口时，需要提供接口的声明。比如，`stdio` 模块实现了函数 `puts`，那么其他模块使用该函数时，就需要写上 `puts` 的声明，即 `int puts(const char *)`：

```c
int puts(const char *);
int main() {
  puts("Hello, world!");
}
```

这样，编译器就会将 `puts` 视为一个外部符号，并要求链接器在重定位时再将其改为具体的符号引用。

但是对于模块的使用者而言，逐个写出需要使用的模块符号声明显然不现实：不仅麻烦，而且使用者可能根本不知道符号的具体声明（如果模块编写者不公布源代码又没有对应的文档）。因此，模块编写者将所有接口的声明都写入一个头文件，并且公布出来供使用模块的人直接通过 `#include` 方式包含进其源代码。

???+ question "为什么可以不提供模块的源代码？"
    因为模块编译过程是互相独立的，因此模块作者可以只提供模块的目标文件供使用者链接即可。

    我们把这种不公布源代码的行为叫做**闭源**，反之称作**开源**（open source）。

对于 `stdio` 模块，对应其接口声明的头文件就是 `stdio.h`（C）或 `cstdio`（C++），里面包含了所有 `stdio` 接口的声明，`puts` 自然也在其中。于是，我们可以修改上文看到的 Hello World 程序：

```c
#include <stdio.h>
int main() {
  puts("Hello, world!");
}
```

这就是我们所常见的 Hello World 程序的形式了。经由上述内容，我们写代码必带的头文件总算解开了其神秘的面纱：它是对应模块接口声明的集合。

#### 重定位与链接

???+ question "为什么通过链接来合并模块，而非直接合并模块的源代码一次性编译？"
    + **节约构建时间。**如果合并源码编译，那么每进行一次修改，就要重新完整编译一次项目（甚至连着标准库的源码一起）。如果每个模块分别编译可以只重新编译改变了的模块，并重新进行链接。
    + **允许闭源提供模块。**有些商业公司并不希望你在使用他们开发的模块时得到他们的高级语言源码，直接提供二进制模块文件可以避免这一点。
    + **方便动态链接。**如果编译前就需要知道所有模块的源代码，那么无法进行动态链接，相同模块的二进制代码无法在运行时复用。

#### 运用 Make 进行构建

##### 

???+ example "手动构建项目"

    之前我们说过可以通过 `make -n` 来查看项目构建时 `make` 运行的命令。

    假设 `make` 不存在，你应该如何构建整个项目呢？既然你已经了解了项目构建的流程了，不妨动手试试看。

## 代码架构

### 代码整体架构大观

### 玩转宏定义：`ansi.h` 与 `debug.h`

#### C/C++ 的源码跨平台方案：条件编译

##### 忍不住的题外话

部分不了解电脑的用户可能会问：为什么电脑上的程序，手机不能运行？而许多 Mac 用户也许还会问：为什么其他电脑的程序，苹果电脑不能运行？

稍微熟悉电脑的用户会知道：这是因为平台差异导致的。平台差异是可以是操作系统的差异，也可以是[指令集体系结构（ISA）](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B) 的差异，甚至是一些微小的[二进制应用接口（ABI）](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)的差异，总之是**运行时环境**的差异。用通俗的语言来表达，可以说即使同是机器语言，不同的机器所能应用的却是略有不同的「方言」（ABI/操作系统差异），乃至完全不通的「外语」（指令集差异）。

但是，平台差异导致程序不能跨平台运行，对于用户可能只是多下载一份二进制文件的功夫，而对于程序员则是一个大麻烦。程序员希望自己只需要编写并构建一次，就可以得到能在所有平台上运行的程序，而不是针对每个平台各自构建一份程序甚至各自编写一份代码。这种程序跨平台的能力，曾经被总结为一个口号「Build once, run everywhere」（构建一次，到处运行）。

但是，由上文介绍的 C/C++ 构建流程可以看出，C/C++ 天生难以做到所谓「构建一次，到处运行」的特性——因为它们的构建目标是真正的机器代码，而我们说过，不同平台的机器语言可能有差异，甚至完全不互通。

???+ info "兼容技术"

    平台与应用的支持是相互的：应用需要支持用户使用平台，而平台也需要支持用户使用的程序。而应用或限于成本或限于时间等原因，有时不会广泛支持需要运行该应用的平台，于是平台间就会形成应用壁垒，而产生所谓的「平台生态」问题。
    
    平台生态的重要性不言而喻：大家常说苹果手机「应用生态好」，就是指 iOS 平台独占的高质量应用较多；前阵子 Mac 从 x86 指令集转移到 ARM 指令集，使得原有的应用生态受到打击；国产 CPU、国产操作系统等国产平台也因为支持的应用较少而面临严重的生态问题；Windows Phone 则因为在升级时不兼容老版平台的应用而被市场淘汰出局。

    因此，平台有时需要想办法具有运行只支持另一平台的程序（也就是「兼容」它们）。

    要兼容不同平台的程序，常见的方法有三种：
    
    + 兼容层。
    + **虚拟机（Virtual Machine），或模拟器（Emulator）。**简单来说，虚拟机和模拟器是一种**模拟物理计算机**运行的软件。
    + 二进制翻译。上述 Mac 迁移到 Arm 指令集之后，为缓解对其平台的影响，采用了 Rosetta2 动态二进制转义系统（之所以是2，是因为苹果曾经也从 PowerPC 指令集切换到 x86 指令集）

    P.S. 据说 yzh 从事过这方面的研究。


如果世界上只有 Windows、Android 等几个平台还好，但是


条件编译是代码跨平台的重要保证。

### 从结构体到面向对象：Minitui 组件库

大家在 OJ 的练习中，一定已经使用过了结构体的语法。我们现在来回顾一下结构体的定义：

+ 结构体是一个自定义数据类型。我们知道 C/C++ 中有一些*基础数据类型*，如 `int`, `float`


### 本部分思考题

#### 代码组织与构建

+ 假设现欲添加一个名为 `glob_value` 的 `int` 类型全局变量，并要求源代码通过包含一个头文件 `glob_value.h` 就可以访问该变量，`glob_value.h` 里应该如何写？源代码应该作何修改（可以添加新文件）？
+ 指出 `Makefile` 中 `CXXFLAGS` 变量最终的值。假设要为游戏的所有源代码文件增加一个 `common/include` 的 `#include` 搜索路径，应该如何修改 `Makefile` （当然，你不要真的修改 `Makefile`）？
+ `ansi.h` 并未被 `Makefile` 文件中的代码指定为任何目标的依赖，本身也没有被指定为目标。为什么在修改 `ansi.h` 后，执行 `make compile` 会导致部分源代码被重新编译？或者说，`Makefile` 是如何识别头文件依赖的？你的回答应该尽可能详细。
<br />提示：查看编译后 `build` 目录下的 `*.d` 文件，并查阅 `g++` 中 `-MMD` 命令的作用。

#### 玩转宏定义

+ `"\033[?1049h"` 可以启用所谓的备用缓冲区。请用 `ansi.h` 中定义的宏写出启用备用缓冲区的代码，你的代码应该尽可能短。
+ 解释 `## __VA_ARGS__` 的意思。为什么 `debug.h` 中使用 `## __VA_ARGS__` 而不是 `__VA_ARGS__` ？
+ 假设现欲兼容 MacOS，原来的条件编译代码可以写为：
```cpp
#ifdef _WIN64
// some code functions in Windows
#else
// some code functions in Linux
#endif
```
兼容 MacOS 后，条件编译代码应该写作什么形式？

#### 面向对象初步

+ 列出 `mainscr` 类的所有成员变量和函数，并分别指出它们是被继承关系上的哪个类定义的。如果是虚函数，分别指出该虚函最初继承自哪个抽象类，并是在哪个类被实现的？
+ 菱形继承和虚继承是 C++ 继承机制中最麻烦的一环，容易产生错综复杂，难以理清的编译问题。上网查询资料，哪些面向对象的高级语言对此进行了改进？进行了什么改进？

#### 附加题

+ 学习 `sed`。`Makefile` 编译 `%.cpp` 时采用了如下规则：
```makefile
$(BUILD_DIR)/%.o : %.cpp
    # ...
    @sed -i 's/[A-Z]:\//\/\l&/g' $(patsubst %.o, %.d, $@)
    @sed -i 's/:\//\//g' $(patsubst %.o, %.d, $@)
```
请问这两行 `sed` 命令目的为何？<br />学习 `cygpath` 命令的使用，请给出一种更好的达成前述目的的方案。


<!-- +（面向对象初步）现有一个基类 `Foo` 及其派生类 `Bar`，我们有如下代码：
```cpp
struct Foo {
    // some code
    const char *instanceOf() const {
        return "Foo";
    }
};
struct Bar {
    //some code
    const char *instanceof() const {
        return "Bar";
    }
}
``` -->
<!-- +（面向对象初步，开放题）如果有两个类 B、C 继承了 A，同时又有一个类 D 继承了 B、C，你觉得会引发什么问题？你觉得这体现出了继承机制的什么缺陷？上网查询资料，其他面向对象的高级语言对此进行了什么改进？ -->

