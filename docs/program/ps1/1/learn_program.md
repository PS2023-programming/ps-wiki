# 框架代码导读

!!! Warning "难度警示"

    我们在上手任何任务时都存在一个学习曲线。在项目任务中，尤其是对于零基础的同学，这将会是学习曲线最为陡峭之处。*请充分重视第一阶段，否则你很有可能无法完成后续所有阶段。*

    这一部分要求完成的任务很少，而我们仍为它[安排了一周的时间](../../../../schedule/ps1/#_5)，**但这不是中间休息时间**。我们希望你能用一周的时间[认真阅读讲义](../../../#_3)，并确保理解了框架的代码。

!!! info "关于 GPT 的使用"

    请尽量不要让 GPT 等大语言模型直接帮你生成作业代码。你可以让它为你解释讲义中你看不懂的技术细节，也可以让它为你提供某样技术细节的实现乃至示例代码。

    但如果你直接让 GPT 生成项目需要添加的代码，可能会有如下几点后果：

    + 你可能并不懂 GPT 的代码为何能够工作，这可能令你在后续需要修改该代码时遇到困难。
    + GPT 的代码可能是错误的，而你没有进行足够的阅读或理解工作，导致你无法进行项目。

RTFSC 是 Reading The Fucking Source Code 的缩写，来自于 [Linus](https://zh.wikipedia.org/wiki/%E6%9E%97%E7%BA%B3%E6%96%AF%C2%B7%E6%89%98%E7%93%A6%E5%85%B9) 在邮件中的「友善」嘴臭。

虽然骂人不好，但这话更像自言自语，有如「It's time to read the fucking source code」。它提醒我们：无论是在初步接手一个项目，抑或是遇到了一些疑难杂症时，沉下心来读一读源代码都很可能对我们大有裨益。

但不少同学作为初学者，哪怕对于小型项目的结构和代码都感到一头雾水：为什么有这么多源文件？各种代码文件之间有什么关系？代码里怎么到处都是我没见过的 token 和语法？该怎么编译整个项目？要知道这些问题的答案，必须对一些 C/C++ 的高级语法，以及 C/C++ 项目的构建具有基本的知识。

由此，作为第一阶段的开端，在本部分中我们为大家介绍阅读框架代码所必须的前置知识，并通过阅读代码了解框架代码的大略架构。

## 代码组织与构建

在第零阶段我们说过，项目中共有两个可执行文件：游戏和启动器。

启动器是一个单源文件程序，而游戏对应着多份源代码。在 OJ 中，大家也许习惯于编写一个源文件而得到对应的程序，但是对于复杂的项目，只使用一个源文件构建得到一个程序是不现实的。试想如果一个源文件中有着数万乃至数十万行代码，会使得阅读和维护代码变得多么麻烦？

因此，我们需要将代码按照模块分成多个文件。你可以在如下目录下找到游戏的源代码：`test/phase1` 和 `minitui`。你还会注意到代码文件分为两类：

+ `.h` 结尾的**头文件**（Header File），一般存放在 `include` 目录下。
+ `.cpp` 结尾的**源文件**（Source File），一般存放在 `source` 目录下。

下面我们来细讲一下这两类文件的区别和作用，并介绍一下预编译命令以及代码的构建流程。

???+ tip "你的程序真的是「单源文件」的吗？"
    虽然你只编写了一个源代码文件，但编译得到的程序许多功能（如输入/输出，文件读写，系统调用等）并不是在这份源代码中实现的，甚至也不是在你引用的头文件中实现的（在 `stdio.h` 中找不到 `printf` 的实现）。
    
    这些功能是在哪里实现的？又是如何被你编写的程序所使用的？读完「代码组织与构建」部分你将会有所认识。

### 头文件和 `#include`

你每次编写的代码的第一行都有可能是 `#include <cstdio>` 或 `#include <iostream>` 乃至 `#include <bits/stdc++.h>`。这些尖括号内的文件就是标准库为我们提供的头文件。

头文件的作用是提供变量的 `extern` 声明和[函数声明](../../../../lang/func/)（这些声明的具体作用我们后面讨论），它一般通过 `#include` 命令而被引入到程序中（这种引入就是文本替换，并可以递归）。

`#include` 这种以 `#` 起始的命令叫做**预编译命令**。处理预编译命令是 C/C++ 源文件编译流程的第一步，我们在此后还会遇见其它的预编译命令，它们同样具有重要作用。

???+ example "观察 `#include` 命令的作用和预编译过程"
    你可以写一个简单的 Hello World 程序（`hello.cpp`），并使用如下命令指示编译器进行预编译：

    ```shell
    g++ -E hello.cpp -o hello_pre.cpp
    ```

    观察 `hello_pre.cpp`，你发现了什么？

#### 头文件的搜索路径

在引用头文件如 `cstdio.h` 时，我们发现头文件既不在代码文件对应的目录下，也不在 `PATH` 环境变量所指定的路径下，GCC 到底是从哪里找到这个文件的呢？

如果你使用带语法提示的编辑器或 IDE，那么在没有预先配置的情形下你可能会发现引用诸如 `ansi.h` 或 `basics.h` 时会被标红线，提示找不到该文件，但编译却可以通过，这是为什么呢？

这些都和 `#include<$FILE>` 时编译器的搜索路径有关。在这一格式的命令中，编译器会从标准库 `include` 路径下寻找对应的文件，然后从用户指定的 `include` 路径中寻找文件。如果你执行 `echo | gcc -xc++ -E -v -` 命令，你将会看到：

```shell
#include <...> search starts here:
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include/c++
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include/c++/x86_64-pc-msys
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include/c++/backward
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/include-fixed
 /usr/include
 /usr/lib/gcc/x86_64-pc-msys/11.3.0/../../../../lib/../include/w32api
```

要想增加 `#include<>` 的搜索路径，可以使用 GCC 提供的 `-I` 选项，试试执行 `echo | gcc -xc++ -E -v -I . -`，输出结果出现了什么不同？

### 可执行程序的构建

*本部分为了切合大家的学习阶段作了简化。在《计算机系统基础》中大家会学习到更详细、严谨的内容。*

通过解析 `#include` 等预编译命令，我们将头文件和源文件合并为许多经过预处理的源文件。那么，这些源文件（一个或多个）又是如何被处理为一个可执行程序的呢？接下来我们就来介绍。

TODO：解释可执行程序到底是啥，以及其和源代码中元素的对应关系。

#### 构建流程

在[理论课堂](http://cslabcms.nju.edu.cn/problem_solving/images/a/a1/Lecture1-6_2019-11-12_%E5%A6%82%E4%BD%95%E5%B0%86%E7%AE%97%E6%B3%95%E5%91%8A%E8%AF%89%E8%AE%A1%E7%AE%97%E6%9C%BA.pptx)上，我们已经知道了「将程序告诉计算机」的方式——二进制（机器语言）。在课堂上，我们还看到了编程语言从机器语言、汇编语言再到高级程序设计语言的演进。

而在可执行程序的构建中，我们则是反其道而行之——从高级程序设计语言的源文件，得到汇编语言文件，再得到二进制程序。

但是，对于多源文件的程序，它又是怎么样构建成一个二进制程序的呢？是先合并源代码，再统一翻译，还是在每份源代码翻译之后合并呢？下面我们就来介绍。

可执行程序的构建流程大体可分为预处理、编译、汇编、链接四个步骤，前三步是每份源代码独立经历的。构建只针对源文件而不直接针对头文件。

+ 预处理 `cpp`：在这一步，源文件所有的 `#` 预编译命令都被展开。头文件在此步被引入。
+ 编译 `ccl`：在这一步，预处理后的源文件被**分别**编译成汇编代码文件。
+ 汇编 `as`：在这一步，汇编代码文件被**分别**编译为可重定位目标文件（`.o` 文件），在 Windows 平台上，它是 [COFF 格式](https://en.wikipedia.org/wiki/COFF0)，在 Linux 平台上，它是 [ELF 格式](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)。
+ 链接 `ld`：在这一步，多个可重定位目标文件被**链接**成一个完整的可执行文件，在 Windows 平台上，它是 [PE 格式](https://en.wikipedia.org/wiki/Portable_Executable)，即常见的 exe 程序，在 Linux 平台上，它仍是 [ELF 格式](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)。

上述流程可以被表示为：

![构建流程](../../../../pics/project-1-1.png)

GCC 提供了精细控制构建流程的选项，展示如下：

```text
-E      Preprocess only; do not compile, assemble or link.
-S      Compile only; do not assemble or link.
-c      Compile and assemble, but do not link.
```

我们不是很关心预处理、编译所得到的中间产物。为方便起见，我们把预处理、编译、汇编三步（图上显示的「翻译器」过程）统称为编译，即把一个源代码文件翻译成一个目标文件的过程。

多源文件的编程事实上是一种**模块化编程**。我们把每个源文件对应的部分称为一个**模块**。一个模块有对应的源代码文件（C/C++ 源代码）和目标文件（二进制，ELF/COFF）。在源代码文件中，模块由函数与全局变量构成。在二进制文件中，与它们相对应的分别是模块的代码和数据。

我们接下来介绍一下编译和链接的原理。

#### 目标文件编译与符号

在这里我们不谈论将模块源代码编译成目标文件的具体方法，也不赘述目标文件的结构细节，需要明确的只是一点：目标文件（ELF/COFF）由模块的二进制代码和数据构成，这些代码和数据在运行时处于[计算机（冯诺依曼结构）](https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)的内存之中，但是由于模块编译的独立性，在被其链接以前，其所含代码/数据在内存中最终所处的位置/地址是不确定的。

然而，模块的运作不是完全相互独立的：一个模块可能需要用到别的模块的**全局变量**或函数（即代码/数据），也可能需要提供变量和函数供其他模块使用。由于各模块不知道其他模块的代码/数据的在内存中的相对位置/地址，要做到这两件事是十分困难的。

为了解决这个问题，编译器必须在编译目标文件时，留下这个模块提供的接口信息，以使链接器在构建最终的可执行程序时能够正确改写各模块，从而令模块间能够正常交互。

???+ example "为什么编译器不能产生最终的模块代码而需要链接器在链接时改写各模块？"
    请自己思考一下，确认是否理解了到此为止的讲义内容——如果你理解了，答案是很明显的。

为了解决模块间的互相引用问题，在实践中，我们在目标文件中添加**符号表**与**重定位节**作为额外接口信息。其中符号指的是全局变量/函数的名称，重定位节用于存放目标文件中所有引用到外部符号的位置。

这个设计的原理是：

+ 当我们通过名称引用一个特定函数/变量（下称符号）时，如果引用的是一个外部符号，编译器并不知道其在最终可执行文件中的确切地址，因此它只能将此符号作为**弱符号**放入目标文件的符号表中，并将目标文件引用符号的位置放入重定位节，以通知链接器在安排模块内存排布后，确定所有符号的确切地址之后改写重定位节指示的部分。
+ 当我们需要将一个特定符号提供给其他模块使用时，我们首先在模块源代码中**定义**（全局变量初始化或函数实现）该符号，而编译器则会将该符号作为一个**强符号**放入符号表中，来通知链接器某一符号的定义在本模块中，以便其在安排好每个模块的内存排布后，确定每个符号的最终地址。

我们把上面的问题称作**跨模块符号引用**。

但是，编译器并不会无脑把所有没有在本模块中**定义**（的符号都当作可能的外部符号。它要求所有符号在使用前都事先**声明**。这是因为，为了将符号引用翻译成机器语言，编译器需要声明来知道**一个符号的引用方法**（符号是函数还是变量，是什么类型，有哪些参数）？

声明包括名称（也就是函数或变量名），类型（变量类型或函数原型），性质（静态/全局）。如果声明符号的对应定义位于本模块中，那么这个符号将是一个**强符号**，也可以不位于本模块中（**弱符号**）。

???+ info "外部变量的声明"

    未赋初始值的变量默认视为一个弱符号。如果想显式表明一个变量是一个弱符号，使用 `extern` 关键字。

对于那些在本模块中无法确定其绝对地址或者相对地址的符号，编译器会留下重定位信息（即 `.rel.text` 和 `.rel.data` 节），要求链接器在链接时为自己替换模块中的符号引用地址（即**重定位**）。另外，对于声明过的所有强符号或弱符号，编译器都会将它们的信息写入目标文件，以供链接器使用。这样生成的文件就是**可重定位目标文件**。

#### 头文件的常规用法：接口声明的集合

一个模块可能实现了若干它希望被其他模块使用的函数和变量，我们把它们称作**接口**。当其他模块需要使用接口时，需要提供接口的声明。比如，`stdio` 模块实现了函数 `puts`，那么其他模块使用该函数时，就需要写上 `puts` 的声明，即 `int puts(const char *)`：

```c
int puts(const char *);
int main() {
  puts("Hello, world!");
}
```

这样，编译器就会将 `puts` 视为一个外部符号，并要求链接器在重定位时再将其改为具体的符号引用。

但是对于模块的使用者而言，逐个写出需要使用的模块符号声明显然不现实：不仅麻烦，而且使用者可能根本不知道符号的具体声明（如果模块编写者不公布源代码又没有对应的文档）。因此，模块编写者将所有接口的声明都写入一个头文件，并且公布出来供使用模块的人直接通过 `#include` 方式包含进其源代码。

???+ question "为什么可以不提供模块的源代码？"
    因为模块编译过程是互相独立的，因此模块作者可以只提供模块的目标文件供使用者链接即可。

    我们把这种不公布源代码的行为叫做**闭源**，反之称作**开源**（open source）。

对于 `stdio` 模块，对应其接口声明的头文件就是 `stdio.h`（C）或 `cstdio`（C++），里面包含了所有 `stdio` 接口的声明，`puts` 自然也在其中。于是，我们可以修改上文看到的 Hello World 程序：

```c
#include <stdio.h>
int main() {
  puts("Hello, world!");
}
```

这就是我们所常见的 Hello World 程序的形式了。经由上述内容，我们写代码必带的头文件总算解开了其神秘的面纱：它是对应模块接口声明的集合。

#### 重定位与链接

TODO：库函数到底实现在哪

TODO：介绍动态链接

???+ question "为什么通过链接来合并模块，而非直接合并模块的源代码一次性编译？"
    + **节约构建时间。**如果合并源码编译，那么每进行一次修改，就要重新完整编译一次项目（甚至连着标准库的源码一起）。如果每个模块分别编译可以只重新编译改变了的模块，并重新进行链接。
    + **允许闭源提供模块。**有些商业公司并不希望你在使用他们开发的模块时得到他们的高级语言源码，直接提供二进制模块文件可以避免这一点。
    + **方便动态链接。**如果编译前就需要知道所有模块的源代码，那么无法进行动态链接，相同模块的二进制代码无法在运行时复用。

???+ example "手动构建项目"

    之前我们说过可以通过 `make -n` 来查看项目构建时 `make` 运行的命令。

    假设 `make` 不存在，你应该如何构建整个项目呢？既然你已经了解了项目构建的流程了，不妨动手试试看。

### 运用 Make 进行构建

一条条手动运行构建项目的命令既麻烦又容易出错。我们在[第零阶段](../../0/complete_shell)介绍了可用于构建的自动化工具 Make 来帮我们解决这一难题。在学习了构建项目的流程之后，现在我们进一步学习如何利用 Make 来自动化构建项目。

首先，在某一目录下执行 `make` 命令时，`make` 会自动寻找指定目录（默认是当前目录，当然也可以通过 `-C DIRECTORY` 指定）下寻找 `Makefile` 或 `makefile` 文件，并按照其中的指示来执行项目的构建。可以看出，运用 Make 的核心就是学会编写 Makefile。

我们接下来简要介绍一下编写 Makefile 的基础知识。

#### Makefile 的基本结构

我们首先介绍 Makefile 中的几个核心概念：

+ **目标（target）。**表示一个 Makefile 需要生成的文件。
+ **依赖（prerequisites）。**表示目标所依赖的文件（可以是其他目标）。
+ **制法（recipe）。**表示生成一个目标需要执行的命令。

以上三部分合起来描述了目标及目标的生成方法，并构成了 Makefile 的一个基本执行单元（本文称其为「规则」），格式如下：

```makefile
target ... : prerequisites ...
    recipe
    ...
```

当执行 `make` 时，Make 会自动寻找文件中第一个出现的目标并以它为生成目标。你也可以用 `make target` 来指定 Make 的生成目标。

Makefile 生成一个目标时，会先检查依赖是否存在，或者是需要构建的目标，如果是需要构建的目标则递归生成目标。

然后 Makefile 检查目标及所有依赖的更新时间，如果目标文件不存在，亦或者某一依赖的最后修改时间比目标的最后修改时间要迟，那么 Makefile 就会执行制法中指定的命令。

Makefile 中还可以定义所谓的**伪目标**。伪目标的目标名并不是真正的文件，而只是一个*操作名*，它被 Makefile 生成时不会产生对应的目标文件，只会执行对应的制法。Makefile 会试图自动识别哪些目标是伪目标，你也可以用 `.PHONY: targets` 来指定。

???+ info "注意缩进"
    Make 对 Makefile 中的缩进敏感。`recipe` 的内容需要有一个 Tab 的缩进。 

???+ info "附加依赖"
    Makefile 的语法很灵活。你可以在定义一个规则的前后为目标添加其它依赖。语法形如 `target ... : prerequisites ...`，不需要添加 `recipe`。

???+ example "结合实际"
    试试阅读项目的 Makefile，你发现了哪些目标？这些目标的依赖关系是怎样的？哪些目标是伪目标？

    你现在可能还看不懂部分 `$(OBJ)` 之类的变量名，可以暂时跳过它们。

#### Makefile 中的模式匹配：`*` 与 `%`

大家也许在理论课堂上已经学过了正则表达式或类似的模式匹配机制。模式匹配能令我们利用计算机迅速筛选出一类符合要求的字符串。

最常用的模式匹配方法是利用通配符来匹配：一个通配符可以匹配空串或任意大小的串，也即「通用匹配」，相当于[正则表达式](https://www.runoob.com/regexp/regexp-tutorial.html)中的 `.*`。在多数场景中，通配符是 `*`，可以试试在项目根目录执行 `echo minitui/include/*.h`，感受一下通配符的作用。

而在 Makefile 中，通配符是 `%` 或 `*`。其中，`%` 是一个「对应」的通配符——在同一上下文中，`%` 匹配一次后，后续出现的 `%` 代表着和第一个 `%` 相同的值。于是，后续多个含有 `%` 的模式就像是一种以通配字符串为词根的「派生模式」。

上述模式能方便地用于进行**模式替换**（将匹配串替换为某一派生串）和**模式规则定义**（一种为某一模式的目标批量定义规则的方法，其中依赖由目标的派生串指定）。我们会在后面提及它们。

#### 模式规则

Makefile 具有为同一模式的文件批量类似的规则的功能，我们将其称为模式规则。模式规则利用 `%` 通配符匹配某一规则的目标，然后对它进行派生以得到依赖列表。举个简单的例子，我们希望将所有的 `.c` 文件编译为同目录下的同名 `.o` 文件，于是我们可以写出这样的模式规则：

```Makefile
%.o : %.c
    gcc %.c -o %.o
```

然而很遗憾，以上规则并不能运作，因为 Make 不会将 Recipe 中的 `%` 进行替换，要在 Recipe 中引用目标名、依赖名、「词根」等，我们必须引入所谓**特殊变量**，以下是一些常用的特殊变量：

+ `$@`：目标。
+ `$<`：第一个依赖。
+ `$^`：所有的依赖（去重）。
+ `$+`：所有的依赖（不去重）。
+ `$?`: 所有比目标更新的依赖。
+ `$*`: 「词根」，即 `%` 匹配的字符串。

于是我们可以改写上面的规则作：

```makefile
%.o : %.c
    gcc $< -o $@
```

这样我们就为所有 `.c` 结尾的文件定义了一个编译规则。

#### Makefile 变量

我们在上文提及了一些 Makefile 的特殊变量，现在我们来详细介绍一下 Makefile 变量。

Makefile 的变量本质上是字符串，引用变量的方式是 `$`，如果一个变量名是 `VAR`，对其值的引用就是 `$(VAR)`。

变量可按照四种方法进行定义：

+ **递归赋值。**`VAR=EXPR` 表示定义 `VAR` 为 `EXPR`，`EXPR` 中可以含有变量，其值使用的是**最终的**变量值。也就是会递归计算完引用的变量的变量值再计算 `VAR` 的值。*这种方法可能导致死循环，应当避免循环引用。*
+ **直接赋值。**`VAR:=EXPR` 同样表示定义 `VAR` 为 `EXPR`，但引用变量使用的是**当前的**变量值。
+ **追加赋值。**`VAR+=EXPR` 表示在 `VAR` 的后面添加一个空格和 `EXPR` 的值。引用的变量如果未定义，则采用递归赋值风格，否则以该变量定义时使用的赋值风格为准。
+ **缺省赋值。**`VAR?=EXPR` 表示当 `VAR` 此时未定义时将 `VAR` 定义为 `EXPR`。

Makefile 中可以使用系统内的环境变量。但同名变量以 Makefile 内定义的为优先。

同时，变量还有作用域之分。普通定义的变量是只在本文件中生效的，而有些变量则是**可继承的**，在 recipe 中执行的 `make` 子进程会继承它们的值。为定义可继承的变量，可以利用 `export` 关键字来修饰变量定义，或在 `make` 时利用 `make VAR=XXX` 指定变量的值。另外，可以用 `override` 关键字来覆盖从父进程继承的变量。

值得一提的是，Makefile 中还有变量内联模式替换的语法，如 `$(VAR:%.o=%.c)` 能将所有 `VAR` 中 `.o` 结尾的元素替换为 `.c` 结尾。

???+ question "什么是元素？"
    在 Makefile 中，元素是字符串（变量或常量）中以空格为边界的子串（其实一般把它们叫做 token，这里姑且译作元素）。下文将字符串作为函数参数时，它被视为以空格分隔的元素的列表。当我们需要组合多个元素时，也将它们用空格分隔拼接成字符串（比如上文`$^`，在引用它时所有依赖就以空格组合为一个字符串）。

#### Makefile 函数

Makefile 还有一些内置函数供编写者引用。函数引用的格式和变量引用相似，即 `$(func args...)`，其中参数按照要求以逗号分隔。我们列举几个典型的内置函数，其他的内置函数大家在碰到时自行搜索或者在文档中查询：

+ 字符串/路径处理函数。
    - `$(basename STRS)` 将 STRS 每个元素去除后缀名后的结果返回。
    - `$(patsubst PAT1, PAT2, STRS)` 将 STRS 中符合模式 PAT1 的元素替换为模式 PAT2 后返回。
    - `$(addprefix PREFIX, STRS)`，将 STRS 的所有元素添加 PREFIX 作为前缀后返回。 
    - `$(wildcard PAT)`，将搜索路径中所有符合 PAT 模式的路径或文件名返回。
+ 打印输出函数。
    - `$(error MSG)`。
    - `$(warning MSG)`。
    - `$(echo MSG)`。
+ Shell 调用函数。
    - `$(shell cmd)`，执行 `cmd` 对应的 Shell 命令，并将其输出的内容返回。
    <br />*注意命令中的 `$` 需用 `$$` 转义。*

??? example "结合实际"
    阅读项目代码，现在你能够看懂项目

#### 条件语句

Makefile 具有通过条件语句选择性保留代码的功能。其基本格式如下：

```text
if-statement (condition)
    ...
else
    ...
endif
```

条件语句包含的代码可以是变量声明/定义等，也可以是 `recipe` 中的内容。在实际执行时，只有满足条件的代码会被保留。

条件语句具有四种形式的 `if-statement`：

+ `ifdef ()`
+ `ifndef ()`
+ `ifeq`
+ `ifneq`

???+ example "结合实际"
    阅读项目 Makefile 中的条件语句，你觉得它们起到了什么功能？

???+ note "进一步学习"
    要进一步了解 Makefile 的编写和 Make 的使用，可以参考两样资料。

    + [GNU make 官方文档](https://www.gnu.org/software/make/manual/make.html)。这里有对于 Make 和 Makefile 用法和规范的最详尽和权威的描述。
    + [跟我一起写 Makefile](../../../../files/Makefile.pdf)。这是一个初学者友好，循序渐进的中文教程。上文介绍 Makefile 的内容也参考了此教程。*该教程的作者[陈皓](https://coolshell.cn/haoel/)于 2023 年 5 月猝然去世。R. I. P.*。

!!! abstract "Makefile 思考题"
    结合上文所述的 Makefile 基本知识和项目 Makefile 的代码内容，完成如下思考题：
    
    + 指出 `Makefile` 中 `CXXFLAGS` 变量最终的值。假设要为游戏的所有源代码文件增加一个 `common/include` 的 `#include` 搜索路径，应该如何修改 `Makefile` （当然，你不要真的修改 `Makefile`）？
    
    + `ansi.h` 并未被 `Makefile` 文件中的代码指定为任何目标的依赖，本身也没有被指定为目标。为什么在修改 `ansi.h` 后，执行 `make compile` 会导致部分源代码被重新编译？或者说，`Makefile` 是如何识别头文件依赖的？你的回答应该尽可能详细。
    <br />*提示：查看编译后 `build` 目录下的 `*.d` 文件，并查阅 `g++` 中 `-MMD` 命令的作用。*


## 代码架构

### 代码整体架构大观

### 玩转宏定义：`ansi.h` 与 `debug.h`

#### 条件编译

条件编译是代码跨平台的重要保证。

### 从结构体到面向对象：Minitui 组件库

大家在 OJ 的练习中，一定已经使用过了结构体的语法。我们现在来回顾一下结构体的定义：

+ 结构体是一个自定义数据类型。我们知道 C/C++ 中有一些*基础数据类型*，如 `int`, `float`


## 附录：本篇思考题汇总

### 代码组织与构建

+ 假设现欲添加一个名为 `glob_value` 的 `int` 类型全局变量，并要求源代码通过包含一个头文件 `glob_value.h` 就可以访问该变量，`glob_value.h` 里应该如何写？源代码应该作何修改（可以添加新文件）？
+ 指出 `Makefile` 中 `CXXFLAGS` 变量最终的值。假设要为游戏的所有源代码文件增加一个 `common/include` 的 `#include` 搜索路径，应该如何修改 `Makefile` （当然，你不要真的修改 `Makefile`）？
+ `ansi.h` 并未被 `Makefile` 文件中的代码指定为任何目标的依赖，本身也没有被指定为目标。为什么在修改 `ansi.h` 后，执行 `make compile` 会导致部分源代码被重新编译？或者说，`Makefile` 是如何识别头文件依赖的？你的回答应该尽可能详细。
<br />提示：查看编译后 `build` 目录下的 `*.d` 文件，并查阅 `g++` 中 `-MMD` 命令的作用。

### 玩转宏定义

+ `"\033[?1049h"` 可以启用所谓的备用缓冲区。请用 `ansi.h` 中定义的宏写出启用备用缓冲区的代码，你的代码应该尽可能短。
+ 解释 `## __VA_ARGS__` 的意思。为什么 `debug.h` 中使用 `## __VA_ARGS__` 而不是 `__VA_ARGS__` ？
+ 假设现欲兼容 MacOS，原来的条件编译代码可以写为：
```cpp
#ifdef _WIN64
// some code functions in Windows
#else
// some code functions in Linux
#endif
```
兼容 MacOS 后，条件编译代码应该写作什么形式？

### 面向对象初步

+ 列出 `mainscr` 类的所有成员变量和函数，并分别指出它们是被继承关系上的哪个类定义的。如果是虚函数，分别指出该虚函最初继承自哪个抽象类，并是在哪个类被实现的？
+ 菱形继承和虚继承是 C++ 继承机制中最麻烦的一环，容易产生错综复杂，难以理清的编译问题。上网查询资料，哪些面向对象的高级语言对此进行了改进？进行了什么改进？

### 附加题

+ 学习 `sed`。`Makefile` 编译 `%.cpp` 时采用了如下规则：
```makefile
$(BUILD_DIR)/%.o : %.cpp
    # ...
    @sed -i 's/[A-Z]:\//\/\l&/g' $(patsubst %.o, %.d, $@)
    @sed -i 's/:\//\//g' $(patsubst %.o, %.d, $@)
```
请问这两行 `sed` 命令目的为何？<br />学习 `cygpath` 命令的使用，请给出一种更好的达成前述目的的方案。


<!-- +（面向对象初步）现有一个基类 `Foo` 及其派生类 `Bar`，我们有如下代码：
```cpp
struct Foo {
    // some code
    const char *instanceOf() const {
        return "Foo";
    }
};
struct Bar {
    //some code
    const char *instanceof() const {
        return "Bar";
    }
}
``` -->
<!-- +（面向对象初步，开放题）如果有两个类 B、C 继承了 A，同时又有一个类 D 继承了 B、C，你觉得会引发什么问题？你觉得这体现出了继承机制的什么缺陷？上网查询资料，其他面向对象的高级语言对此进行了什么改进？ -->

## 附录：跨平台构建机制


部分不了解电脑的用户可能会问：为什么电脑上的程序，手机不能运行？而许多 Mac 用户也许还会问：为什么其他电脑的程序，苹果电脑不能运行？

稍微熟悉电脑的用户会知道：这是因为平台差异导致的。平台差异是可以是操作系统的差异，也可以是[指令集体系结构（ISA）](https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B) 的差异，甚至是一些微小的[二进制应用接口（ABI）](https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3)的差异，总之是**运行时环境**的差异。用通俗的语言来表达，可以说即使同是机器语言，不同的机器所能应用的却是略有不同的「方言」（ABI/操作系统差异），乃至完全不通的「外语」（指令集差异）。

但是，平台差异导致程序不能跨平台运行，对于用户可能只是多下载一份二进制文件的功夫，而对于程序员则是一个大麻烦。程序员希望自己只需要编写并构建一次，就可以得到能在所有平台上运行的程序，而不是针对每个平台各自构建一份程序甚至各自编写一份代码。这种程序跨平台的能力，曾经被总结为一个口号「Build once, run everywhere」（构建一次，到处运行）。

但是，由上文介绍的 C/C++ 构建流程可以看出，C/C++ 天生难以做到所谓「构建一次，到处运行」的特性——因为它们的构建目标是真正的机器代码，而我们说过，不同平台的机器语言可能有差异，甚至完全不互通。

???+ info "兼容技术"

    平台与应用的支持是相互的：应用需要支持用户使用平台，而平台也需要支持用户使用的程序。而应用或限于成本或限于时间等原因，有时不会广泛支持需要运行该应用的平台，于是平台间就会形成应用壁垒，而产生所谓的「平台生态」问题。
    
    平台生态的重要性不言而喻：大家常说苹果手机「应用生态好」，就是指 iOS 平台独占的高质量应用较多；前阵子 Mac 从 x86 指令集转移到 ARM 指令集，使得原有的应用生态受到打击；国产 CPU、国产操作系统等国产平台也因为支持的应用较少而面临严重的生态问题；Windows Phone 则因为在升级时不兼容老版平台的应用而被市场淘汰出局。

    因此，平台有时需要想办法具有运行只支持另一平台的程序（也就是「兼容」它们）。

    要兼容不同平台的程序，常见的方法有三种：
    
    + 兼容层。
    + **虚拟机（Virtual Machine），或模拟器（Emulator）。**简单来说，虚拟机和模拟器是一种**模拟物理计算机**运行的软件。
    + 二进制翻译。上述 Mac 迁移到 Arm 指令集之后，为缓解对其平台的影响，采用了 Rosetta2 动态二进制转义系统（之所以是2，是因为苹果曾经也从 PowerPC 指令集切换到 x86 指令集）

    P.S. 据说 yzh 从事过这方面的研究。


如果世界上只有 Windows、Android 等几个平台还好，但是
